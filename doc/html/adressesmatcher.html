<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>icip.adressesmatcher API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>icip.adressesmatcher</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import difflib
import config
import entities
import time
import argparse
import repositories
import art
from typing import Dict, Set, List, Tuple, Optional, Iterable

time0 = time.perf_counter()


class AdresseMatcher:
    &#34;&#34;&#34;
    Fusionne ps-tarifs et adresses
    &#34;&#34;&#34;

    def __init__(self):
        self.db: Dict[str, entities.AdresseEntity] = {}
        self.communes_db: Dict[str, Set[str]] = {}
        self.cps_db: Dict[int, Set[str]] = {}
        self.nb = 0
        self.nbbadcp = 0
        self.nbnostreet = 0
        self.nbscorelow = 0
        self.rownum = 0
        self.nberror500 = 0
        self.nbcedexbp = 0
        self.nonum = 0
        self.nbbadcommune = 0
        self.nbbadinsee = 0
        self.total = 1
        self.i = 0
        self.pss_db = []
        self.ps_repo = repositories.PSRepository()
        self.a_repo = repositories.AdresseRepository()
        self.keys_db = {}
        self.adresses_db = {}
        self.insees_db = {}
        self.cedex_db = {}
        self.csv = []
        self.new_adresse = False

    def log(self, msg: str):
        &#34;&#34;&#34;
        Log
        :param msg:
        &#34;&#34;&#34;
        span = int(time.perf_counter() - time0)
        s = f&#34;{span}s&#34;
        if span &gt;= 6000:
            s = f&#34;{span // 3600}h{(span % 3600) // 60}m&#34;
        elif span &gt;= 600:
            s = f&#34;{span // 60}m{span % 60}s&#34;
        print(f&#34;{s} {(self.i / self.total)*100:.1f}% [{self.rownum}] {msg}&#34;)

    def split_num(self, s: str) -&gt; Tuple[int, str]:
        &#34;&#34;&#34;
        Split s en fonction du numero
        :param s: chaine
        :return: tuple numéro, reste de la chaine
        &#34;&#34;&#34;
        regex = r&#34;(\d+)&#34;
        match = re.match(regex, s)
        if match is None:
            self.nonum += 1
            return 0, s
        num = match[1]
        index = s.index(match[1])
        return int(num), s[index + len(num):].strip()

    def find_nearest_less_cp(self, cp: int) -&gt; int:
        &#34;&#34;&#34;
        Retrouve le code postal immédiatement inférieur pour les CEDEX
        :param cp:
        :return:
        &#34;&#34;&#34;
        min = 99999
        res = 0
        for k in self.cps_db.keys():
            dif = cp - k
            if 0 &lt;= dif &lt; min:
                min = dif
                res = k
        return res

    def find_nearest_num(self, num: int, nums: List[int]) -&gt; int:
        &#34;&#34;&#34;
        Trouve le numéro de rue le plus proche de num parmis nums, encourange les mêmes côtés de rue
        :param num: le numéro à rechercher
        :param nums: la lsite de numéro dans lesquels chercher
        :return: le numéro proche trouvé
        &#34;&#34;&#34;
        res = 0
        difmin = 99999
        for n in nums:
            dif = abs(num - n)
            if dif % 2 == 1:
                dif *= 3
            if dif &lt; difmin:
                res = n
                difmin = dif
        return res

    def gestalt(self, s1, s2):
        sm = difflib.SequenceMatcher(None, s1, s2)
        return sm.ratio()

    def gestalts(self, s: str, l: Iterable[str]):
        &#34;&#34;&#34;
        Machine Learning Gestalt
        Applique Gestalt sur s et tous les éléments de l
        :param s: la chaine de gauche
        :param l: la liste des chaine de droite à comparer
        :return: le meilleur score
        &#34;&#34;&#34;
        if s == &#34;&#34;:
            return &#34;&#34;, 0
        max = -1
        res = 0
        s = self.denormalize_street(s)
        for item in l:
            if item != &#34;&#34;:
                if item.startswith(s) or s.startswith(item):
                    return item, 0.99
                deno = self.denormalize_street(item)
                ratio = self.gestalt(s, deno)
                if ratio &gt; max:
                    max = ratio
                    res = item
        return res, max

    def normalize_street(self, street: str) -&gt; str:
        &#34;&#34;&#34;
        Normalise la rue
        :param street: rue
        :return: rue normalisée
        &#34;&#34;&#34;
        street = street.upper().replace(&#34;&#39;&#34;, &#34; &#34;).replace(&#34;-&#34;, &#34; &#34;).replace(&#34;.&#34;, &#34;&#34;).replace(&#34;/&#34;, &#34; &#34;).replace(&#39;&#34;&#39;, &#34;&#34;)
        street = &#34; &#34; + street
        if &#34; BP&#34; in street:
            self.nbcedexbp += 1
            street.replace(&#34; BP&#34;, &#34;&#34;)
        street = street.replace(&#34; CH &#34;, &#34; CHEMIN &#34;).replace(&#34; AV &#34;, &#34; AVENUE &#34;).replace(&#34; PL &#34;, &#34; PLACE &#34;)
        street = street.replace(&#34; BD &#34;, &#34; BOULEVARD &#34;).replace(&#34; IMP &#34;, &#34; IMPASSE &#34;).replace(&#34; ST &#34;, &#34; SAINT &#34;)
        street = street.replace(&#34; RT &#34;, &#34; ROUTE &#34;).replace(&#34; GAL &#34;, &#34; GENERAL &#34;)
        return street.strip()

    def denormalize_street(self, street: str) -&gt; str:
        &#34;&#34;&#34;
        Denormalise la rue
        :param street: rue
        :return: rue dénormalisée
        &#34;&#34;&#34;
        street = street.replace(&#34;CHEMIN&#34;, &#34;CH&#34;).replace(&#34;AVENUE&#34;, &#34;AV&#34;).replace(&#34;PLACE&#34;, &#34;PL&#34;)
        street = street.replace(&#34;BOULEVARD&#34;, &#34;BD&#34;).replace(&#34;ROUTE&#34;, &#34;RT&#34;)
        return street

    def normalize_commune(self, commune: str) -&gt; str:
        &#34;&#34;&#34;
        Normalise la commune
        :param commune: commune
        :return: la commune normalisée
        &#34;&#34;&#34;
        if &#34;CEDEX&#34; in commune:
            self.nbcedexbp += 1
            index = commune.index(&#34;CEDEX&#34;)
            commune = commune[:index]
        commune = commune.upper().replace(&#34;&#39;&#34;, &#34; &#34;).replace(&#34;-&#34;, &#34; &#34;).replace(&#34;.&#34;, &#34;&#34;).replace(&#34;/&#34;, &#34; &#34;)
        commune = &#34; &#34; + commune
        commune = commune.replace(&#34; ST &#34;, &#34; SAINT &#34;).replace(&#34; STE &#34;, &#34; SAINTE &#34;)
        return commune.strip()

    def match_cp(self, cp: int) -&gt; Tuple[int, float]:
        &#34;&#34;&#34;
        Match le code postal
        :param cp: le code postal
        :return: le code postal matché
        &#34;&#34;&#34;
        # cp = special.cp_cedex(cp)
        if cp in self.cps_db:
            return cp, 1.0
        elif 1000 &gt; cp &gt;= 97000:
            self.nbbadcp += 1
            return 0, 0.0
        elif 75100 &lt;= cp &lt; 75200:
            self.nbbadcp += 1
            cp, score = self.match_cp(cp - 100)
            return cp, score * 0.9
        elif cp in self.cedex_db:
            insee = self.cedex_db[cp].code_insee
            if insee in self.insees_db:
                res = list(self.insees_db[insee])[0]
                # self.log(f&#34;WARNING CEDEX {cp}=&gt;{res}&#34;)
                return res, 0.9
            else:
                self.nbbadinsee += 1
                self.nbbadcp += 1
                self.log(f&#34;ERROR BAD INSEE {cp} {insee}&#34;)
                return self.find_nearest_less_cp(cp), 0.25
        else:
            self.nbbadcp += 1
            res = self.find_nearest_less_cp(cp)
            self.log(f&#34;ERROR CP DOES NOT EXIST {cp}=&gt;{res}&#34;)
            return res, 0.5

    def match_commune(self, commune: str, communes: Set[str], cp: int) -&gt; Tuple[str, float]:
        &#34;&#34;&#34;
        Match la commune
        :param commune: la commune
        :param communes: la liste des communes à matcher
        :param cp: le code postal
        :return: la commune matchée
        &#34;&#34;&#34;
        # commune = special.commune(cp, commune)
        if commune in communes:
            return commune, 1.0
        elif len(communes) == 1:
            return list(communes)[0], 0.95
        else:
            res, score = self.gestalts(commune, communes)
            self.log(f&#34;WARNING COMMUNE {cp} {commune}=&gt;{res} @{int(score*100)}%&#34;)
            return res, score

    def match_street(self, commune: str, adresse2: str, adresse3: str, cp: int) -&gt; Tuple[str, float]:
        &#34;&#34;&#34;
        Match l&#39;adresse3
        :param commune: la commune
        :param adresse2: adresse2
        :param adresse3: adresse3
        :param cp: le code postal
        :return: la rue de la commune matchée
        &#34;&#34;&#34;
        # adresse3 = special.street(cp, adresse3)
        ids = self.communes_db[commune]
        entities = [self.db[id] for id in ids]
        adresses = [e.nom_afnor for e in entities if e.code_postal == cp]
        adresses_voie = [e.nom_voie for e in entities if e.code_postal == cp]
        if adresse3 == &#34;&#34;:
            self.nbnostreet += 1
            adresse3 = &#34;MAIRIE EGLISE&#34;
        if adresse3 in adresses:
            return adresse3, 1.0
        if adresse3 in adresses_voie:
            index = adresses_voie.index(adresse3)
            return adresses[index], 0.99
        res, score = self.gestalts(adresse3, adresses)
        if score &gt; 0.8:
            return res, score
        res2, score2 = self.gestalts(adresse2, adresses)
        if score2 &gt; 0.8:
            return res2, score2
        res3, score3 = self.gestalts(adresse3, adresses_voie)
        if score + 0.1 &gt; max(score2, score3):
            return res, score
        if score2 &gt; score3:
            return res2, score2 * 0.8
        index = adresses_voie.index(res3)
        return adresses[index], score3 * 0.9

    def match_num(self, commune: str, adresse: str, num: int) -&gt; Tuple[Optional[entities.AdresseEntity], float]:
        &#34;&#34;&#34;
        Match le numéro de rue
        :param commune: la commune
        :param adresse: la rue
        :param num: le numéro
        :return: le numéro de la rue matché
        &#34;&#34;&#34;
        ids = self.communes_db[commune]
        adresses = [self.db[id] for id in ids]
        if num == 0:
            adresses = [e for e in adresses if e.nom_afnor == adresse]
            if len(adresses) &gt; 0:
                if adresses[0].numero == 0:
                    return adresses[0], 1.0
                else:
                    return adresses[0], 0.9
            else:
                return None, 0.0
        else:
            founds = [e for e in adresses if e.nom_afnor == adresse and e.numero == num]
            if len(founds) &gt; 0:
                return founds[0], 1.0
            else:
                nums = [e.numero for e in adresses if e.nom_afnor == adresse]
                res = self.find_nearest_num(num, nums)
                founds = [e for e in adresses if e.nom_afnor == adresse and e.numero == res]
                if len(founds) &gt; 0:
                    score = max(1 - abs(res - num) / 10, 0.5)
                    return founds[0], score
                return None, 0.0  # Normalement impossible

    def get_cp_by_commune(self, commune: str, oldcp: int) -&gt; Tuple[int, str, float]:
        &#34;&#34;&#34;
        Retrouve le code postal par la commune et le code code postal faux
        :param commune: la commune
        :param oldcp: le code postal en échec
        :return: le code postal trouvé, la commune et le score
        &#34;&#34;&#34;
        if commune in self.communes_db:
            ids = self.communes_db[commune]
            dept = str(oldcp)[:2] if oldcp &gt;= 10000 else &#34;0&#34; + str(oldcp)[:1]
            for id in ids:
                e = self.db[id]
                if e.commune == commune and str(e.code_postal)[:2] == dept:
                    return e.code_postal, e.commune, 0.9
                if e.commune.startswith(commune) and str(e.code_postal)[:2] == dept:
                    return e.code_postal, e.commune, 0.75
        return oldcp, commune, 0

    def last_chance(self, commune: str, adresse3: str, num: int) -&gt; Optional[entities.AdresseEntity]:
        &#34;&#34;&#34;
        Retrouve un code postal par commune, adresse3 et numero
        :param commune: la commune
        :param adresse3: adresse3
        :param num: numéro
        :return: l&#39;entité adresse
        &#34;&#34;&#34;
        if commune in self.communes_db:
            ids = self.communes_db[commune]
            for id in ids:
                e = self.db[id]
                if e.commune == commune and (e.nom_afnor == adresse3 or e.nom_voie == adresse3) and e.numero == num:
                    return e
        return None

    def very_last_chance(self, cp: int, adresse3: str, num: int) -&gt; Optional[entities.AdresseEntity]:
        &#34;&#34;&#34;
        Retrouve une commune par code postal, adresse3 et numéro
        :param cp: Le code postal
        :param adresse3: adresse3
        :param num: le numéro
        :return: l&#39;entité Adresse
        &#34;&#34;&#34;
        if cp in self.cps_db:
            communes = self.cps_db[cp]
            for commune in communes:
                ids = self.communes_db[commune]
                for id in ids:
                    e = self.db[id]
                    if e.code_postal == cp and (e.nom_afnor == adresse3 or e.nom_voie == adresse3) and e.numero == num:
                        return e
        return None

    def update_entity(self, entity: entities.PSEntity, aentity: entities.AdresseEntity, score: float):
        &#34;&#34;&#34;
        MAJ PS par rapport à l&#39;adresse
        :param entity: PS
        :param aentity: adresse entity
        :param score: le score de matching
        &#34;&#34;&#34;
        entity.adresseid = aentity.id
        entity.adressescore = score
        entity.lon = aentity.lon
        entity.lat = aentity.lat
        entity.x = aentity.x
        entity.y = aentity.y
        entity.codeinsee = aentity.code_insee
        entity.matchadresse = f&#34;{aentity.numero} {aentity.nom_afnor} {aentity.code_postal} {aentity.commune}&#34;
        entity.matchcp = aentity.code_postal

    def check_low_score(self, entity: entities.PSEntity,
                        adresse3: str, originalnum: int, aentity: entities.AdresseEntity) -&gt; entities.AdresseEntity:
        &#34;&#34;&#34;
        Gère les stratégies de scores bas
        :param entity: l&#39;entité
        :param adresse3: adresse3
        :param originalnum: le numéro originel
        :param aentity: l&#39;entité adresse matchée avec un mauvais score
        :return: l&#39;entié adresse matchée après les last chances
        &#34;&#34;&#34;
        if entity.score &lt; config.adresse_quality:
            res = self.last_chance(self.normalize_commune(entity.commune), self.normalize_street(adresse3), originalnum)
            if res is not None:
                aentity = res
                if aentity.code_postal != entity.cp:
                    self.nbbadcp += 1
                    self.log(f&#34;WARNING CORRECTING CP: {entity.cp} {entity.commune}=&gt;{aentity.code_postal}&#34;
                             f&#34; {aentity.commune}&#34;)
                entity.scores[0] = 0.5 if aentity.code_postal != entity.cp else 0.9
                entity.scores[1] = entity.scores[2] = entity.scores[3] = 0.99
            else:
                res = self.very_last_chance(int(entity.cp), self.normalize_street(adresse3), originalnum)
                if res is not None:
                    aentity = res
                    if aentity.commune != entity.commune:
                        self.nbbadcommune += 1
                        self.log(f&#34;WARNING CORRECTING COMMUNE: {entity.cp} {entity.commune}=&gt;{aentity.code_postal}&#34;
                                 f&#34; {aentity.commune}&#34;)
                    entity.scores[1] = 0.5 if aentity.commune != entity.commune else 0.9
                    entity.scores[0] = entity.scores[2] = entity.scores[3] = 0.98
        if entity.score &lt; config.adresse_quality:
            self.nbscorelow += 1
            self.log(f&#34;LOW SCORE: {int(entity.score * 100)}% ({(self.nbscorelow / (self.nb + 1)) * 100:.1f}%)&#34;
                     f&#34; {entity.adresse3} {entity.cp} {entity.commune} =&gt; {aentity.numero} {aentity.nom_afnor}&#34;
                     f&#34; {aentity.code_postal} {aentity.commune}&#34;)
        if aentity is None:
            aentity = entities.AdresseEntity(0)
            self.log(f&#34;ERROR UNKNOWN {entity.adresse3} {entity.cp} {entity.commune}&#34;)
            self.nberror500 += 1
        return aentity

    def parse_ps(self, dept: int):
        &#34;&#34;&#34;
        Fonction principale, charge PS et match un département
        :param dept: un département
        &#34;&#34;&#34;
        self.rownum = 0
        for row in self.csv:
            self.i += 1
            self.rownum += 1
            cp = int(row[7])
            if ((dept * 1000) &lt;= cp &lt; (dept + 1) * 1000 and cp != 201 and cp != 202) or \
                    (dept == 201 and 20000 &lt;= cp &lt; 20200) or \
                    (dept == 202 and 20200 &lt;= cp &lt; 21000):
                self.nb += 1
                entity = entities.PSEntity()
                entity.rownum = self.rownum
                self.ps_repo.row2entity(entity, row)
                t = (entity.cp, entity.commune, entity.adresse3, entity.adresse2)
                if t in self.adresses_db:
                    aentity = self.db[self.adresses_db[t][0]]
                    self.update_entity(entity, aentity, self.adresses_db[t][1])
                    self.keys_db[entity.id] = (entity.adresseid, entity.score)
                    self.pss_db.append(entity)
                    if entity.adressescore &lt; config.adresse_quality:
                        self.nbscorelow += 1
                else:
                    cp, score = self.match_cp(cp)
                    entity.scores.append(score)
                    communes = self.cps_db[cp]
                    commune = self.normalize_commune(entity.commune)
                    commune, score = self.match_commune(commune, communes, cp)
                    entity.scores.append(score)
                    if score &lt; 0.8:
                        cp2, commune2, score2 = self.get_cp_by_commune(self.normalize_commune(entity.commune), cp)
                        if score2 &gt; score and cp2 != entity.cp:
                            self.log(f&#34;WARNING BAD CP {entity.cp} {entity.commune}=&gt;{cp2} {commune2}&#34;)
                            self.nbbadcp += 1
                            cp = cp2
                            commune = commune2
                            entity.scores[1] = score2
                            entity.scores[0] = 0.5
                    adresse3 = self.normalize_street(entity.adresse3)
                    adresse2 = self.normalize_street(entity.adresse2)
                    num, adresse3 = self.split_num(adresse3)
                    if num == 0 and adresse2 != &#34;&#34;:
                        num, adresse2 = self.split_num(adresse2)
                    originalnum = num
                    matchadresse, score = self.match_street(commune, adresse2, adresse3, cp)
                    entity.scores.append(score)
                    aentity, score = self.match_num(commune, matchadresse, num)
                    entity.scores.append(score)
                    aentity = self.check_low_score(entity, adresse3, originalnum, aentity)
                    self.update_entity(entity, aentity, entity.score)
                    self.pss_db.append(entity)
                    self.keys_db[entity.id] = (entity.adresseid, entity.score)
                    self.adresses_db[t] = (entity.adresseid, entity.score)
                    self.new_adresse = True

    def display(self):
        print(f&#34;Nb PS: {self.nb}&#34;)
        print(f&#34;Nb Matching PS: {len(self.pss_db)} {(len(self.pss_db) / self.nb) * 100 : .1f}%&#34;)
        print(f&#34;Nb Unique PS: {len(self.keys_db)} ({self.nb / len(self.keys_db):.1f} rows/PS)&#34;)
        print(f&#34;Nb Unique Adresse: {len(self.adresses_db)} ({self.nb / len(self.adresses_db):.1f} rows/PS)&#34;)
        print(f&#34;Nb No num: {self.nonum} {(self.nonum / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Cedex BP: {self.nbcedexbp} {(self.nbcedexbp / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Bad CP: {self.nbbadcp} {(self.nbbadcp / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Bad commune: {self.nbbadcommune} {(self.nbbadcommune / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb No Street: {self.nbnostreet} {(self.nbnostreet / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Error Unknown: {self.nberror500} {(self.nberror500 / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Bad INSEE: {self.nbbadinsee}&#34;)
        print(f&#34;Nb Score low: {self.nbscorelow} {(self.nbscorelow / self.nb) * 100 : .1f}%&#34;)

    def load_by_depts(self, file: str, depts: Optional[List[int]] = None, cache=False):
        &#34;&#34;&#34;
        Prépare le chargement de PS en fonction d&#39;une liste de département
        :param file: PS
        :param depts: la liste de département, None = all
        :param cache: use ps_adresses.csv
        &#34;&#34;&#34;
        self.log(f&#34;Load {file}&#34;)
        self.csv = self.ps_repo.load_ps(file)
        self.total = len(self.csv)
        self.log(f&#34;Load {config.cedex_path}&#34;)
        self.cedex_db = self.a_repo.load_cedex()
        if cache:
            self.log(f&#34;Load {config.adresse_db_path}&#34;)
            self.adresses_db = self.a_repo.load_adresses_db()
        if depts is None:
            depts = list(range(1, 20)) + list(range(21, 96)) + [201, 202]
        self.total *= len(depts)
        for dept in depts:
            self.log(f&#34;Load dept {dept}&#34;)
            self.db, self.communes_db, self.cps_db, self.insees_db = self.a_repo.load_adresses(dept)
            self.parse_ps(dept)
        self.display()
        self.pss_db.sort(key=lambda e: e.rownum)
        file = file.replace(&#34;.csv&#34;, &#34;-adresses.csv&#34;)
        self.ps_repo.save_entities(file, self.pss_db)
        if self.new_adresse and cache:
            self.a_repo.save_adresses_db(self.adresses_db)
        self.log(f&#34;Saved {self.nb} PS&#34;)


if __name__ == &#39;__main__&#39;:
    art.tprint(config.name, &#34;big&#34;)
    print(&#34;Adresses Matcher&#34;)
    print(&#34;================&#34;)
    print(f&#34;V{config.version}&#34;)
    print(config.copyright)
    print()
    parser = argparse.ArgumentParser(description=&#34;Adresses Matcher&#34;)
    parser.add_argument(&#34;path&#34;, help=&#34;Path&#34;)
    parser.add_argument(&#34;-d&#34;, &#34;--dept&#34;, help=&#34;Departments list in python format, eg [5,38,06]&#34;)
    parser.add_argument(&#34;-c&#34;, &#34;--cache&#34;, help=&#34;Using ps_adresses.csv&#34;, action=&#34;store_true&#34;)
    args = parser.parse_args()
    am = AdresseMatcher()
    if args.dept is None:
        am.load_by_depts(args.path, None, args.cache)
    else:
        am.load_by_depts(args.path, eval(args.dept), args.cache)

    # 38
    # Nb PS: 48927
    # Nb Matching PS: 48927  100.0%
    # Nb Unique PS: 3028 (16.2 rows/PS)
    # Nb Unique Adresse: 7688 (6.4 rows/PS)
    # Nb No num: 286  3.7%
    # Nb Cedex BP: 132  1.7%
    # Nb Bad CP: 28  0.4%
    # Nb Bad commune: 6  0.1%
    # Nb No Street: 2  0.0%
    # Nb Error Unknown: 0  0.0%
    # Nb Bad INSEE: 0
    # Nb Score low: 1779  3.6%
    # Save data/ps/ps-tarifs-21-03-adresses.csv
    # Save data/ps/ps_adresses.csv
    # 116s 100.0% [2455164] Saved 48927 PS

    # 48
    # Nb PS: 1620
    # Nb Matching PS: 1620  100.0%
    # Nb Unique PS: 129 (12.6 rows/PS)
    # Nb Unique Adresse: 102 (15.9 rows/PS)
    # Nb No num: 66  64.7%
    # Nb Cedex BP: 0  0.0%
    # Nb Bad CP: 0  0.0%
    # Nb Bad commune: 0  0.0%
    # Nb No Street: 2  2.0%
    # Nb Error Unknown: 0  0.0%
    # Nb Bad INSEE: 0
    # Nb Score low: 1  1.0%
    # Save data/ps/ps-tarifs-21-03-adresses.csv
    # 14s 100.0% [2455164] Saved 1620 PS

    # 75
    # Nb PS: 100214
    # Nb Matching PS: 100214  100.0%
    # Nb Unique PS: 8921 (11.2 rows/PS)
    # Nb Unique Adresse: 5581 (18.0 rows/PS)
    # Nb No num: 0  0.0%
    # Nb Cedex BP: 68  1.2%
    # Nb Bad CP: 325  5.8%
    # Nb Bad commune: 0  0.0%
    # Nb No Street: 0  0.0%
    # Nb Error Unknown: 0  0.0%
    # Nb Bad INSEE: 0
    # Nb Score low: 89  0.1%
    # Save data/ps/ps-tarifs-21-03-adresses.csv
    # Save data/ps/ps_adresses.csv
    # 20m46s 100.0% [2455164] Saved 100214 PS

    # Nb PS: 2401126
    # Nb Matching PS: 2401126  100.0%
    # Nb Unique PS: 151248 (15.9 rows/PS)
    # Nb Unique Adresse: 94784 (25.3 rows/PS)
    # Nb No num: 14214  15.0%
    # Nb Cedex BP: 5127  5.4%
    # Nb Bad CP: 1204  1.3%
    # Nb Bad commune: 51  0.1%
    # Nb No Street: 213  0.2%
    # Nb Error Unknown: 0  0.0%
    # Nb Bad INSEE: 19
    # Nb Score low: 37583  1.6%
    # Save data/ps/ps-tarifs-21-03-adresses.csv
    # Save data/ps/ps_adresses.csv
    # 2h53m 100.0% [2455164] Saved 2401126 PS</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="icip.adressesmatcher.AdresseMatcher"><code class="flex name class">
<span>class <span class="ident">AdresseMatcher</span></span>
</code></dt>
<dd>
<div class="desc"><p>Fusionne ps-tarifs et adresses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdresseMatcher:
    &#34;&#34;&#34;
    Fusionne ps-tarifs et adresses
    &#34;&#34;&#34;

    def __init__(self):
        self.db: Dict[str, entities.AdresseEntity] = {}
        self.communes_db: Dict[str, Set[str]] = {}
        self.cps_db: Dict[int, Set[str]] = {}
        self.nb = 0
        self.nbbadcp = 0
        self.nbnostreet = 0
        self.nbscorelow = 0
        self.rownum = 0
        self.nberror500 = 0
        self.nbcedexbp = 0
        self.nonum = 0
        self.nbbadcommune = 0
        self.nbbadinsee = 0
        self.total = 1
        self.i = 0
        self.pss_db = []
        self.ps_repo = repositories.PSRepository()
        self.a_repo = repositories.AdresseRepository()
        self.keys_db = {}
        self.adresses_db = {}
        self.insees_db = {}
        self.cedex_db = {}
        self.csv = []
        self.new_adresse = False

    def log(self, msg: str):
        &#34;&#34;&#34;
        Log
        :param msg:
        &#34;&#34;&#34;
        span = int(time.perf_counter() - time0)
        s = f&#34;{span}s&#34;
        if span &gt;= 6000:
            s = f&#34;{span // 3600}h{(span % 3600) // 60}m&#34;
        elif span &gt;= 600:
            s = f&#34;{span // 60}m{span % 60}s&#34;
        print(f&#34;{s} {(self.i / self.total)*100:.1f}% [{self.rownum}] {msg}&#34;)

    def split_num(self, s: str) -&gt; Tuple[int, str]:
        &#34;&#34;&#34;
        Split s en fonction du numero
        :param s: chaine
        :return: tuple numéro, reste de la chaine
        &#34;&#34;&#34;
        regex = r&#34;(\d+)&#34;
        match = re.match(regex, s)
        if match is None:
            self.nonum += 1
            return 0, s
        num = match[1]
        index = s.index(match[1])
        return int(num), s[index + len(num):].strip()

    def find_nearest_less_cp(self, cp: int) -&gt; int:
        &#34;&#34;&#34;
        Retrouve le code postal immédiatement inférieur pour les CEDEX
        :param cp:
        :return:
        &#34;&#34;&#34;
        min = 99999
        res = 0
        for k in self.cps_db.keys():
            dif = cp - k
            if 0 &lt;= dif &lt; min:
                min = dif
                res = k
        return res

    def find_nearest_num(self, num: int, nums: List[int]) -&gt; int:
        &#34;&#34;&#34;
        Trouve le numéro de rue le plus proche de num parmis nums, encourange les mêmes côtés de rue
        :param num: le numéro à rechercher
        :param nums: la lsite de numéro dans lesquels chercher
        :return: le numéro proche trouvé
        &#34;&#34;&#34;
        res = 0
        difmin = 99999
        for n in nums:
            dif = abs(num - n)
            if dif % 2 == 1:
                dif *= 3
            if dif &lt; difmin:
                res = n
                difmin = dif
        return res

    def gestalt(self, s1, s2):
        sm = difflib.SequenceMatcher(None, s1, s2)
        return sm.ratio()

    def gestalts(self, s: str, l: Iterable[str]):
        &#34;&#34;&#34;
        Machine Learning Gestalt
        Applique Gestalt sur s et tous les éléments de l
        :param s: la chaine de gauche
        :param l: la liste des chaine de droite à comparer
        :return: le meilleur score
        &#34;&#34;&#34;
        if s == &#34;&#34;:
            return &#34;&#34;, 0
        max = -1
        res = 0
        s = self.denormalize_street(s)
        for item in l:
            if item != &#34;&#34;:
                if item.startswith(s) or s.startswith(item):
                    return item, 0.99
                deno = self.denormalize_street(item)
                ratio = self.gestalt(s, deno)
                if ratio &gt; max:
                    max = ratio
                    res = item
        return res, max

    def normalize_street(self, street: str) -&gt; str:
        &#34;&#34;&#34;
        Normalise la rue
        :param street: rue
        :return: rue normalisée
        &#34;&#34;&#34;
        street = street.upper().replace(&#34;&#39;&#34;, &#34; &#34;).replace(&#34;-&#34;, &#34; &#34;).replace(&#34;.&#34;, &#34;&#34;).replace(&#34;/&#34;, &#34; &#34;).replace(&#39;&#34;&#39;, &#34;&#34;)
        street = &#34; &#34; + street
        if &#34; BP&#34; in street:
            self.nbcedexbp += 1
            street.replace(&#34; BP&#34;, &#34;&#34;)
        street = street.replace(&#34; CH &#34;, &#34; CHEMIN &#34;).replace(&#34; AV &#34;, &#34; AVENUE &#34;).replace(&#34; PL &#34;, &#34; PLACE &#34;)
        street = street.replace(&#34; BD &#34;, &#34; BOULEVARD &#34;).replace(&#34; IMP &#34;, &#34; IMPASSE &#34;).replace(&#34; ST &#34;, &#34; SAINT &#34;)
        street = street.replace(&#34; RT &#34;, &#34; ROUTE &#34;).replace(&#34; GAL &#34;, &#34; GENERAL &#34;)
        return street.strip()

    def denormalize_street(self, street: str) -&gt; str:
        &#34;&#34;&#34;
        Denormalise la rue
        :param street: rue
        :return: rue dénormalisée
        &#34;&#34;&#34;
        street = street.replace(&#34;CHEMIN&#34;, &#34;CH&#34;).replace(&#34;AVENUE&#34;, &#34;AV&#34;).replace(&#34;PLACE&#34;, &#34;PL&#34;)
        street = street.replace(&#34;BOULEVARD&#34;, &#34;BD&#34;).replace(&#34;ROUTE&#34;, &#34;RT&#34;)
        return street

    def normalize_commune(self, commune: str) -&gt; str:
        &#34;&#34;&#34;
        Normalise la commune
        :param commune: commune
        :return: la commune normalisée
        &#34;&#34;&#34;
        if &#34;CEDEX&#34; in commune:
            self.nbcedexbp += 1
            index = commune.index(&#34;CEDEX&#34;)
            commune = commune[:index]
        commune = commune.upper().replace(&#34;&#39;&#34;, &#34; &#34;).replace(&#34;-&#34;, &#34; &#34;).replace(&#34;.&#34;, &#34;&#34;).replace(&#34;/&#34;, &#34; &#34;)
        commune = &#34; &#34; + commune
        commune = commune.replace(&#34; ST &#34;, &#34; SAINT &#34;).replace(&#34; STE &#34;, &#34; SAINTE &#34;)
        return commune.strip()

    def match_cp(self, cp: int) -&gt; Tuple[int, float]:
        &#34;&#34;&#34;
        Match le code postal
        :param cp: le code postal
        :return: le code postal matché
        &#34;&#34;&#34;
        # cp = special.cp_cedex(cp)
        if cp in self.cps_db:
            return cp, 1.0
        elif 1000 &gt; cp &gt;= 97000:
            self.nbbadcp += 1
            return 0, 0.0
        elif 75100 &lt;= cp &lt; 75200:
            self.nbbadcp += 1
            cp, score = self.match_cp(cp - 100)
            return cp, score * 0.9
        elif cp in self.cedex_db:
            insee = self.cedex_db[cp].code_insee
            if insee in self.insees_db:
                res = list(self.insees_db[insee])[0]
                # self.log(f&#34;WARNING CEDEX {cp}=&gt;{res}&#34;)
                return res, 0.9
            else:
                self.nbbadinsee += 1
                self.nbbadcp += 1
                self.log(f&#34;ERROR BAD INSEE {cp} {insee}&#34;)
                return self.find_nearest_less_cp(cp), 0.25
        else:
            self.nbbadcp += 1
            res = self.find_nearest_less_cp(cp)
            self.log(f&#34;ERROR CP DOES NOT EXIST {cp}=&gt;{res}&#34;)
            return res, 0.5

    def match_commune(self, commune: str, communes: Set[str], cp: int) -&gt; Tuple[str, float]:
        &#34;&#34;&#34;
        Match la commune
        :param commune: la commune
        :param communes: la liste des communes à matcher
        :param cp: le code postal
        :return: la commune matchée
        &#34;&#34;&#34;
        # commune = special.commune(cp, commune)
        if commune in communes:
            return commune, 1.0
        elif len(communes) == 1:
            return list(communes)[0], 0.95
        else:
            res, score = self.gestalts(commune, communes)
            self.log(f&#34;WARNING COMMUNE {cp} {commune}=&gt;{res} @{int(score*100)}%&#34;)
            return res, score

    def match_street(self, commune: str, adresse2: str, adresse3: str, cp: int) -&gt; Tuple[str, float]:
        &#34;&#34;&#34;
        Match l&#39;adresse3
        :param commune: la commune
        :param adresse2: adresse2
        :param adresse3: adresse3
        :param cp: le code postal
        :return: la rue de la commune matchée
        &#34;&#34;&#34;
        # adresse3 = special.street(cp, adresse3)
        ids = self.communes_db[commune]
        entities = [self.db[id] for id in ids]
        adresses = [e.nom_afnor for e in entities if e.code_postal == cp]
        adresses_voie = [e.nom_voie for e in entities if e.code_postal == cp]
        if adresse3 == &#34;&#34;:
            self.nbnostreet += 1
            adresse3 = &#34;MAIRIE EGLISE&#34;
        if adresse3 in adresses:
            return adresse3, 1.0
        if adresse3 in adresses_voie:
            index = adresses_voie.index(adresse3)
            return adresses[index], 0.99
        res, score = self.gestalts(adresse3, adresses)
        if score &gt; 0.8:
            return res, score
        res2, score2 = self.gestalts(adresse2, adresses)
        if score2 &gt; 0.8:
            return res2, score2
        res3, score3 = self.gestalts(adresse3, adresses_voie)
        if score + 0.1 &gt; max(score2, score3):
            return res, score
        if score2 &gt; score3:
            return res2, score2 * 0.8
        index = adresses_voie.index(res3)
        return adresses[index], score3 * 0.9

    def match_num(self, commune: str, adresse: str, num: int) -&gt; Tuple[Optional[entities.AdresseEntity], float]:
        &#34;&#34;&#34;
        Match le numéro de rue
        :param commune: la commune
        :param adresse: la rue
        :param num: le numéro
        :return: le numéro de la rue matché
        &#34;&#34;&#34;
        ids = self.communes_db[commune]
        adresses = [self.db[id] for id in ids]
        if num == 0:
            adresses = [e for e in adresses if e.nom_afnor == adresse]
            if len(adresses) &gt; 0:
                if adresses[0].numero == 0:
                    return adresses[0], 1.0
                else:
                    return adresses[0], 0.9
            else:
                return None, 0.0
        else:
            founds = [e for e in adresses if e.nom_afnor == adresse and e.numero == num]
            if len(founds) &gt; 0:
                return founds[0], 1.0
            else:
                nums = [e.numero for e in adresses if e.nom_afnor == adresse]
                res = self.find_nearest_num(num, nums)
                founds = [e for e in adresses if e.nom_afnor == adresse and e.numero == res]
                if len(founds) &gt; 0:
                    score = max(1 - abs(res - num) / 10, 0.5)
                    return founds[0], score
                return None, 0.0  # Normalement impossible

    def get_cp_by_commune(self, commune: str, oldcp: int) -&gt; Tuple[int, str, float]:
        &#34;&#34;&#34;
        Retrouve le code postal par la commune et le code code postal faux
        :param commune: la commune
        :param oldcp: le code postal en échec
        :return: le code postal trouvé, la commune et le score
        &#34;&#34;&#34;
        if commune in self.communes_db:
            ids = self.communes_db[commune]
            dept = str(oldcp)[:2] if oldcp &gt;= 10000 else &#34;0&#34; + str(oldcp)[:1]
            for id in ids:
                e = self.db[id]
                if e.commune == commune and str(e.code_postal)[:2] == dept:
                    return e.code_postal, e.commune, 0.9
                if e.commune.startswith(commune) and str(e.code_postal)[:2] == dept:
                    return e.code_postal, e.commune, 0.75
        return oldcp, commune, 0

    def last_chance(self, commune: str, adresse3: str, num: int) -&gt; Optional[entities.AdresseEntity]:
        &#34;&#34;&#34;
        Retrouve un code postal par commune, adresse3 et numero
        :param commune: la commune
        :param adresse3: adresse3
        :param num: numéro
        :return: l&#39;entité adresse
        &#34;&#34;&#34;
        if commune in self.communes_db:
            ids = self.communes_db[commune]
            for id in ids:
                e = self.db[id]
                if e.commune == commune and (e.nom_afnor == adresse3 or e.nom_voie == adresse3) and e.numero == num:
                    return e
        return None

    def very_last_chance(self, cp: int, adresse3: str, num: int) -&gt; Optional[entities.AdresseEntity]:
        &#34;&#34;&#34;
        Retrouve une commune par code postal, adresse3 et numéro
        :param cp: Le code postal
        :param adresse3: adresse3
        :param num: le numéro
        :return: l&#39;entité Adresse
        &#34;&#34;&#34;
        if cp in self.cps_db:
            communes = self.cps_db[cp]
            for commune in communes:
                ids = self.communes_db[commune]
                for id in ids:
                    e = self.db[id]
                    if e.code_postal == cp and (e.nom_afnor == adresse3 or e.nom_voie == adresse3) and e.numero == num:
                        return e
        return None

    def update_entity(self, entity: entities.PSEntity, aentity: entities.AdresseEntity, score: float):
        &#34;&#34;&#34;
        MAJ PS par rapport à l&#39;adresse
        :param entity: PS
        :param aentity: adresse entity
        :param score: le score de matching
        &#34;&#34;&#34;
        entity.adresseid = aentity.id
        entity.adressescore = score
        entity.lon = aentity.lon
        entity.lat = aentity.lat
        entity.x = aentity.x
        entity.y = aentity.y
        entity.codeinsee = aentity.code_insee
        entity.matchadresse = f&#34;{aentity.numero} {aentity.nom_afnor} {aentity.code_postal} {aentity.commune}&#34;
        entity.matchcp = aentity.code_postal

    def check_low_score(self, entity: entities.PSEntity,
                        adresse3: str, originalnum: int, aentity: entities.AdresseEntity) -&gt; entities.AdresseEntity:
        &#34;&#34;&#34;
        Gère les stratégies de scores bas
        :param entity: l&#39;entité
        :param adresse3: adresse3
        :param originalnum: le numéro originel
        :param aentity: l&#39;entité adresse matchée avec un mauvais score
        :return: l&#39;entié adresse matchée après les last chances
        &#34;&#34;&#34;
        if entity.score &lt; config.adresse_quality:
            res = self.last_chance(self.normalize_commune(entity.commune), self.normalize_street(adresse3), originalnum)
            if res is not None:
                aentity = res
                if aentity.code_postal != entity.cp:
                    self.nbbadcp += 1
                    self.log(f&#34;WARNING CORRECTING CP: {entity.cp} {entity.commune}=&gt;{aentity.code_postal}&#34;
                             f&#34; {aentity.commune}&#34;)
                entity.scores[0] = 0.5 if aentity.code_postal != entity.cp else 0.9
                entity.scores[1] = entity.scores[2] = entity.scores[3] = 0.99
            else:
                res = self.very_last_chance(int(entity.cp), self.normalize_street(adresse3), originalnum)
                if res is not None:
                    aentity = res
                    if aentity.commune != entity.commune:
                        self.nbbadcommune += 1
                        self.log(f&#34;WARNING CORRECTING COMMUNE: {entity.cp} {entity.commune}=&gt;{aentity.code_postal}&#34;
                                 f&#34; {aentity.commune}&#34;)
                    entity.scores[1] = 0.5 if aentity.commune != entity.commune else 0.9
                    entity.scores[0] = entity.scores[2] = entity.scores[3] = 0.98
        if entity.score &lt; config.adresse_quality:
            self.nbscorelow += 1
            self.log(f&#34;LOW SCORE: {int(entity.score * 100)}% ({(self.nbscorelow / (self.nb + 1)) * 100:.1f}%)&#34;
                     f&#34; {entity.adresse3} {entity.cp} {entity.commune} =&gt; {aentity.numero} {aentity.nom_afnor}&#34;
                     f&#34; {aentity.code_postal} {aentity.commune}&#34;)
        if aentity is None:
            aentity = entities.AdresseEntity(0)
            self.log(f&#34;ERROR UNKNOWN {entity.adresse3} {entity.cp} {entity.commune}&#34;)
            self.nberror500 += 1
        return aentity

    def parse_ps(self, dept: int):
        &#34;&#34;&#34;
        Fonction principale, charge PS et match un département
        :param dept: un département
        &#34;&#34;&#34;
        self.rownum = 0
        for row in self.csv:
            self.i += 1
            self.rownum += 1
            cp = int(row[7])
            if ((dept * 1000) &lt;= cp &lt; (dept + 1) * 1000 and cp != 201 and cp != 202) or \
                    (dept == 201 and 20000 &lt;= cp &lt; 20200) or \
                    (dept == 202 and 20200 &lt;= cp &lt; 21000):
                self.nb += 1
                entity = entities.PSEntity()
                entity.rownum = self.rownum
                self.ps_repo.row2entity(entity, row)
                t = (entity.cp, entity.commune, entity.adresse3, entity.adresse2)
                if t in self.adresses_db:
                    aentity = self.db[self.adresses_db[t][0]]
                    self.update_entity(entity, aentity, self.adresses_db[t][1])
                    self.keys_db[entity.id] = (entity.adresseid, entity.score)
                    self.pss_db.append(entity)
                    if entity.adressescore &lt; config.adresse_quality:
                        self.nbscorelow += 1
                else:
                    cp, score = self.match_cp(cp)
                    entity.scores.append(score)
                    communes = self.cps_db[cp]
                    commune = self.normalize_commune(entity.commune)
                    commune, score = self.match_commune(commune, communes, cp)
                    entity.scores.append(score)
                    if score &lt; 0.8:
                        cp2, commune2, score2 = self.get_cp_by_commune(self.normalize_commune(entity.commune), cp)
                        if score2 &gt; score and cp2 != entity.cp:
                            self.log(f&#34;WARNING BAD CP {entity.cp} {entity.commune}=&gt;{cp2} {commune2}&#34;)
                            self.nbbadcp += 1
                            cp = cp2
                            commune = commune2
                            entity.scores[1] = score2
                            entity.scores[0] = 0.5
                    adresse3 = self.normalize_street(entity.adresse3)
                    adresse2 = self.normalize_street(entity.adresse2)
                    num, adresse3 = self.split_num(adresse3)
                    if num == 0 and adresse2 != &#34;&#34;:
                        num, adresse2 = self.split_num(adresse2)
                    originalnum = num
                    matchadresse, score = self.match_street(commune, adresse2, adresse3, cp)
                    entity.scores.append(score)
                    aentity, score = self.match_num(commune, matchadresse, num)
                    entity.scores.append(score)
                    aentity = self.check_low_score(entity, adresse3, originalnum, aentity)
                    self.update_entity(entity, aentity, entity.score)
                    self.pss_db.append(entity)
                    self.keys_db[entity.id] = (entity.adresseid, entity.score)
                    self.adresses_db[t] = (entity.adresseid, entity.score)
                    self.new_adresse = True

    def display(self):
        print(f&#34;Nb PS: {self.nb}&#34;)
        print(f&#34;Nb Matching PS: {len(self.pss_db)} {(len(self.pss_db) / self.nb) * 100 : .1f}%&#34;)
        print(f&#34;Nb Unique PS: {len(self.keys_db)} ({self.nb / len(self.keys_db):.1f} rows/PS)&#34;)
        print(f&#34;Nb Unique Adresse: {len(self.adresses_db)} ({self.nb / len(self.adresses_db):.1f} rows/PS)&#34;)
        print(f&#34;Nb No num: {self.nonum} {(self.nonum / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Cedex BP: {self.nbcedexbp} {(self.nbcedexbp / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Bad CP: {self.nbbadcp} {(self.nbbadcp / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Bad commune: {self.nbbadcommune} {(self.nbbadcommune / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb No Street: {self.nbnostreet} {(self.nbnostreet / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Error Unknown: {self.nberror500} {(self.nberror500 / len(self.adresses_db)) * 100 : .1f}%&#34;)
        print(f&#34;Nb Bad INSEE: {self.nbbadinsee}&#34;)
        print(f&#34;Nb Score low: {self.nbscorelow} {(self.nbscorelow / self.nb) * 100 : .1f}%&#34;)

    def load_by_depts(self, file: str, depts: Optional[List[int]] = None, cache=False):
        &#34;&#34;&#34;
        Prépare le chargement de PS en fonction d&#39;une liste de département
        :param file: PS
        :param depts: la liste de département, None = all
        :param cache: use ps_adresses.csv
        &#34;&#34;&#34;
        self.log(f&#34;Load {file}&#34;)
        self.csv = self.ps_repo.load_ps(file)
        self.total = len(self.csv)
        self.log(f&#34;Load {config.cedex_path}&#34;)
        self.cedex_db = self.a_repo.load_cedex()
        if cache:
            self.log(f&#34;Load {config.adresse_db_path}&#34;)
            self.adresses_db = self.a_repo.load_adresses_db()
        if depts is None:
            depts = list(range(1, 20)) + list(range(21, 96)) + [201, 202]
        self.total *= len(depts)
        for dept in depts:
            self.log(f&#34;Load dept {dept}&#34;)
            self.db, self.communes_db, self.cps_db, self.insees_db = self.a_repo.load_adresses(dept)
            self.parse_ps(dept)
        self.display()
        self.pss_db.sort(key=lambda e: e.rownum)
        file = file.replace(&#34;.csv&#34;, &#34;-adresses.csv&#34;)
        self.ps_repo.save_entities(file, self.pss_db)
        if self.new_adresse and cache:
            self.a_repo.save_adresses_db(self.adresses_db)
        self.log(f&#34;Saved {self.nb} PS&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="icip.adressesmatcher.AdresseMatcher.check_low_score"><code class="name flex">
<span>def <span class="ident">check_low_score</span></span>(<span>self, entity: entities.PSEntity, adresse3: str, originalnum: int, aentity: entities.AdresseEntity) ‑> entities.AdresseEntity</span>
</code></dt>
<dd>
<div class="desc"><p>Gère les stratégies de scores bas
:param entity: l'entité
:param adresse3: adresse3
:param originalnum: le numéro originel
:param aentity: l'entité adresse matchée avec un mauvais score
:return: l'entié adresse matchée après les last chances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_low_score(self, entity: entities.PSEntity,
                    adresse3: str, originalnum: int, aentity: entities.AdresseEntity) -&gt; entities.AdresseEntity:
    &#34;&#34;&#34;
    Gère les stratégies de scores bas
    :param entity: l&#39;entité
    :param adresse3: adresse3
    :param originalnum: le numéro originel
    :param aentity: l&#39;entité adresse matchée avec un mauvais score
    :return: l&#39;entié adresse matchée après les last chances
    &#34;&#34;&#34;
    if entity.score &lt; config.adresse_quality:
        res = self.last_chance(self.normalize_commune(entity.commune), self.normalize_street(adresse3), originalnum)
        if res is not None:
            aentity = res
            if aentity.code_postal != entity.cp:
                self.nbbadcp += 1
                self.log(f&#34;WARNING CORRECTING CP: {entity.cp} {entity.commune}=&gt;{aentity.code_postal}&#34;
                         f&#34; {aentity.commune}&#34;)
            entity.scores[0] = 0.5 if aentity.code_postal != entity.cp else 0.9
            entity.scores[1] = entity.scores[2] = entity.scores[3] = 0.99
        else:
            res = self.very_last_chance(int(entity.cp), self.normalize_street(adresse3), originalnum)
            if res is not None:
                aentity = res
                if aentity.commune != entity.commune:
                    self.nbbadcommune += 1
                    self.log(f&#34;WARNING CORRECTING COMMUNE: {entity.cp} {entity.commune}=&gt;{aentity.code_postal}&#34;
                             f&#34; {aentity.commune}&#34;)
                entity.scores[1] = 0.5 if aentity.commune != entity.commune else 0.9
                entity.scores[0] = entity.scores[2] = entity.scores[3] = 0.98
    if entity.score &lt; config.adresse_quality:
        self.nbscorelow += 1
        self.log(f&#34;LOW SCORE: {int(entity.score * 100)}% ({(self.nbscorelow / (self.nb + 1)) * 100:.1f}%)&#34;
                 f&#34; {entity.adresse3} {entity.cp} {entity.commune} =&gt; {aentity.numero} {aentity.nom_afnor}&#34;
                 f&#34; {aentity.code_postal} {aentity.commune}&#34;)
    if aentity is None:
        aentity = entities.AdresseEntity(0)
        self.log(f&#34;ERROR UNKNOWN {entity.adresse3} {entity.cp} {entity.commune}&#34;)
        self.nberror500 += 1
    return aentity</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.denormalize_street"><code class="name flex">
<span>def <span class="ident">denormalize_street</span></span>(<span>self, street: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Denormalise la rue
:param street: rue
:return: rue dénormalisée</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def denormalize_street(self, street: str) -&gt; str:
    &#34;&#34;&#34;
    Denormalise la rue
    :param street: rue
    :return: rue dénormalisée
    &#34;&#34;&#34;
    street = street.replace(&#34;CHEMIN&#34;, &#34;CH&#34;).replace(&#34;AVENUE&#34;, &#34;AV&#34;).replace(&#34;PLACE&#34;, &#34;PL&#34;)
    street = street.replace(&#34;BOULEVARD&#34;, &#34;BD&#34;).replace(&#34;ROUTE&#34;, &#34;RT&#34;)
    return street</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self):
    print(f&#34;Nb PS: {self.nb}&#34;)
    print(f&#34;Nb Matching PS: {len(self.pss_db)} {(len(self.pss_db) / self.nb) * 100 : .1f}%&#34;)
    print(f&#34;Nb Unique PS: {len(self.keys_db)} ({self.nb / len(self.keys_db):.1f} rows/PS)&#34;)
    print(f&#34;Nb Unique Adresse: {len(self.adresses_db)} ({self.nb / len(self.adresses_db):.1f} rows/PS)&#34;)
    print(f&#34;Nb No num: {self.nonum} {(self.nonum / len(self.adresses_db)) * 100 : .1f}%&#34;)
    print(f&#34;Nb Cedex BP: {self.nbcedexbp} {(self.nbcedexbp / len(self.adresses_db)) * 100 : .1f}%&#34;)
    print(f&#34;Nb Bad CP: {self.nbbadcp} {(self.nbbadcp / len(self.adresses_db)) * 100 : .1f}%&#34;)
    print(f&#34;Nb Bad commune: {self.nbbadcommune} {(self.nbbadcommune / len(self.adresses_db)) * 100 : .1f}%&#34;)
    print(f&#34;Nb No Street: {self.nbnostreet} {(self.nbnostreet / len(self.adresses_db)) * 100 : .1f}%&#34;)
    print(f&#34;Nb Error Unknown: {self.nberror500} {(self.nberror500 / len(self.adresses_db)) * 100 : .1f}%&#34;)
    print(f&#34;Nb Bad INSEE: {self.nbbadinsee}&#34;)
    print(f&#34;Nb Score low: {self.nbscorelow} {(self.nbscorelow / self.nb) * 100 : .1f}%&#34;)</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.find_nearest_less_cp"><code class="name flex">
<span>def <span class="ident">find_nearest_less_cp</span></span>(<span>self, cp: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Retrouve le code postal immédiatement inférieur pour les CEDEX
:param cp:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_nearest_less_cp(self, cp: int) -&gt; int:
    &#34;&#34;&#34;
    Retrouve le code postal immédiatement inférieur pour les CEDEX
    :param cp:
    :return:
    &#34;&#34;&#34;
    min = 99999
    res = 0
    for k in self.cps_db.keys():
        dif = cp - k
        if 0 &lt;= dif &lt; min:
            min = dif
            res = k
    return res</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.find_nearest_num"><code class="name flex">
<span>def <span class="ident">find_nearest_num</span></span>(<span>self, num: int, nums: List[int]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Trouve le numéro de rue le plus proche de num parmis nums, encourange les mêmes côtés de rue
:param num: le numéro à rechercher
:param nums: la lsite de numéro dans lesquels chercher
:return: le numéro proche trouvé</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_nearest_num(self, num: int, nums: List[int]) -&gt; int:
    &#34;&#34;&#34;
    Trouve le numéro de rue le plus proche de num parmis nums, encourange les mêmes côtés de rue
    :param num: le numéro à rechercher
    :param nums: la lsite de numéro dans lesquels chercher
    :return: le numéro proche trouvé
    &#34;&#34;&#34;
    res = 0
    difmin = 99999
    for n in nums:
        dif = abs(num - n)
        if dif % 2 == 1:
            dif *= 3
        if dif &lt; difmin:
            res = n
            difmin = dif
    return res</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.gestalt"><code class="name flex">
<span>def <span class="ident">gestalt</span></span>(<span>self, s1, s2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gestalt(self, s1, s2):
    sm = difflib.SequenceMatcher(None, s1, s2)
    return sm.ratio()</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.gestalts"><code class="name flex">
<span>def <span class="ident">gestalts</span></span>(<span>self, s: str, l: Iterable[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Machine Learning Gestalt
Applique Gestalt sur s et tous les éléments de l
:param s: la chaine de gauche
:param l: la liste des chaine de droite à comparer
:return: le meilleur score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gestalts(self, s: str, l: Iterable[str]):
    &#34;&#34;&#34;
    Machine Learning Gestalt
    Applique Gestalt sur s et tous les éléments de l
    :param s: la chaine de gauche
    :param l: la liste des chaine de droite à comparer
    :return: le meilleur score
    &#34;&#34;&#34;
    if s == &#34;&#34;:
        return &#34;&#34;, 0
    max = -1
    res = 0
    s = self.denormalize_street(s)
    for item in l:
        if item != &#34;&#34;:
            if item.startswith(s) or s.startswith(item):
                return item, 0.99
            deno = self.denormalize_street(item)
            ratio = self.gestalt(s, deno)
            if ratio &gt; max:
                max = ratio
                res = item
    return res, max</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.get_cp_by_commune"><code class="name flex">
<span>def <span class="ident">get_cp_by_commune</span></span>(<span>self, commune: str, oldcp: int) ‑> Tuple[int, str, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrouve le code postal par la commune et le code code postal faux
:param commune: la commune
:param oldcp: le code postal en échec
:return: le code postal trouvé, la commune et le score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cp_by_commune(self, commune: str, oldcp: int) -&gt; Tuple[int, str, float]:
    &#34;&#34;&#34;
    Retrouve le code postal par la commune et le code code postal faux
    :param commune: la commune
    :param oldcp: le code postal en échec
    :return: le code postal trouvé, la commune et le score
    &#34;&#34;&#34;
    if commune in self.communes_db:
        ids = self.communes_db[commune]
        dept = str(oldcp)[:2] if oldcp &gt;= 10000 else &#34;0&#34; + str(oldcp)[:1]
        for id in ids:
            e = self.db[id]
            if e.commune == commune and str(e.code_postal)[:2] == dept:
                return e.code_postal, e.commune, 0.9
            if e.commune.startswith(commune) and str(e.code_postal)[:2] == dept:
                return e.code_postal, e.commune, 0.75
    return oldcp, commune, 0</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.last_chance"><code class="name flex">
<span>def <span class="ident">last_chance</span></span>(<span>self, commune: str, adresse3: str, num: int) ‑> Union[entities.AdresseEntity, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrouve un code postal par commune, adresse3 et numero
:param commune: la commune
:param adresse3: adresse3
:param num: numéro
:return: l'entité adresse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_chance(self, commune: str, adresse3: str, num: int) -&gt; Optional[entities.AdresseEntity]:
    &#34;&#34;&#34;
    Retrouve un code postal par commune, adresse3 et numero
    :param commune: la commune
    :param adresse3: adresse3
    :param num: numéro
    :return: l&#39;entité adresse
    &#34;&#34;&#34;
    if commune in self.communes_db:
        ids = self.communes_db[commune]
        for id in ids:
            e = self.db[id]
            if e.commune == commune and (e.nom_afnor == adresse3 or e.nom_voie == adresse3) and e.numero == num:
                return e
    return None</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.load_by_depts"><code class="name flex">
<span>def <span class="ident">load_by_depts</span></span>(<span>self, file: str, depts: Union[List[int], NoneType] = None, cache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prépare le chargement de PS en fonction d'une liste de département
:param file: PS
:param depts: la liste de département, None = all
:param cache: use ps_adresses.csv</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_by_depts(self, file: str, depts: Optional[List[int]] = None, cache=False):
    &#34;&#34;&#34;
    Prépare le chargement de PS en fonction d&#39;une liste de département
    :param file: PS
    :param depts: la liste de département, None = all
    :param cache: use ps_adresses.csv
    &#34;&#34;&#34;
    self.log(f&#34;Load {file}&#34;)
    self.csv = self.ps_repo.load_ps(file)
    self.total = len(self.csv)
    self.log(f&#34;Load {config.cedex_path}&#34;)
    self.cedex_db = self.a_repo.load_cedex()
    if cache:
        self.log(f&#34;Load {config.adresse_db_path}&#34;)
        self.adresses_db = self.a_repo.load_adresses_db()
    if depts is None:
        depts = list(range(1, 20)) + list(range(21, 96)) + [201, 202]
    self.total *= len(depts)
    for dept in depts:
        self.log(f&#34;Load dept {dept}&#34;)
        self.db, self.communes_db, self.cps_db, self.insees_db = self.a_repo.load_adresses(dept)
        self.parse_ps(dept)
    self.display()
    self.pss_db.sort(key=lambda e: e.rownum)
    file = file.replace(&#34;.csv&#34;, &#34;-adresses.csv&#34;)
    self.ps_repo.save_entities(file, self.pss_db)
    if self.new_adresse and cache:
        self.a_repo.save_adresses_db(self.adresses_db)
    self.log(f&#34;Saved {self.nb} PS&#34;)</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Log
:param msg:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, msg: str):
    &#34;&#34;&#34;
    Log
    :param msg:
    &#34;&#34;&#34;
    span = int(time.perf_counter() - time0)
    s = f&#34;{span}s&#34;
    if span &gt;= 6000:
        s = f&#34;{span // 3600}h{(span % 3600) // 60}m&#34;
    elif span &gt;= 600:
        s = f&#34;{span // 60}m{span % 60}s&#34;
    print(f&#34;{s} {(self.i / self.total)*100:.1f}% [{self.rownum}] {msg}&#34;)</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.match_commune"><code class="name flex">
<span>def <span class="ident">match_commune</span></span>(<span>self, commune: str, communes: Set[str], cp: int) ‑> Tuple[str, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Match la commune
:param commune: la commune
:param communes: la liste des communes à matcher
:param cp: le code postal
:return: la commune matchée</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_commune(self, commune: str, communes: Set[str], cp: int) -&gt; Tuple[str, float]:
    &#34;&#34;&#34;
    Match la commune
    :param commune: la commune
    :param communes: la liste des communes à matcher
    :param cp: le code postal
    :return: la commune matchée
    &#34;&#34;&#34;
    # commune = special.commune(cp, commune)
    if commune in communes:
        return commune, 1.0
    elif len(communes) == 1:
        return list(communes)[0], 0.95
    else:
        res, score = self.gestalts(commune, communes)
        self.log(f&#34;WARNING COMMUNE {cp} {commune}=&gt;{res} @{int(score*100)}%&#34;)
        return res, score</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.match_cp"><code class="name flex">
<span>def <span class="ident">match_cp</span></span>(<span>self, cp: int) ‑> Tuple[int, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Match le code postal
:param cp: le code postal
:return: le code postal matché</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_cp(self, cp: int) -&gt; Tuple[int, float]:
    &#34;&#34;&#34;
    Match le code postal
    :param cp: le code postal
    :return: le code postal matché
    &#34;&#34;&#34;
    # cp = special.cp_cedex(cp)
    if cp in self.cps_db:
        return cp, 1.0
    elif 1000 &gt; cp &gt;= 97000:
        self.nbbadcp += 1
        return 0, 0.0
    elif 75100 &lt;= cp &lt; 75200:
        self.nbbadcp += 1
        cp, score = self.match_cp(cp - 100)
        return cp, score * 0.9
    elif cp in self.cedex_db:
        insee = self.cedex_db[cp].code_insee
        if insee in self.insees_db:
            res = list(self.insees_db[insee])[0]
            # self.log(f&#34;WARNING CEDEX {cp}=&gt;{res}&#34;)
            return res, 0.9
        else:
            self.nbbadinsee += 1
            self.nbbadcp += 1
            self.log(f&#34;ERROR BAD INSEE {cp} {insee}&#34;)
            return self.find_nearest_less_cp(cp), 0.25
    else:
        self.nbbadcp += 1
        res = self.find_nearest_less_cp(cp)
        self.log(f&#34;ERROR CP DOES NOT EXIST {cp}=&gt;{res}&#34;)
        return res, 0.5</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.match_num"><code class="name flex">
<span>def <span class="ident">match_num</span></span>(<span>self, commune: str, adresse: str, num: int) ‑> Tuple[Union[entities.AdresseEntity, NoneType], float]</span>
</code></dt>
<dd>
<div class="desc"><p>Match le numéro de rue
:param commune: la commune
:param adresse: la rue
:param num: le numéro
:return: le numéro de la rue matché</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_num(self, commune: str, adresse: str, num: int) -&gt; Tuple[Optional[entities.AdresseEntity], float]:
    &#34;&#34;&#34;
    Match le numéro de rue
    :param commune: la commune
    :param adresse: la rue
    :param num: le numéro
    :return: le numéro de la rue matché
    &#34;&#34;&#34;
    ids = self.communes_db[commune]
    adresses = [self.db[id] for id in ids]
    if num == 0:
        adresses = [e for e in adresses if e.nom_afnor == adresse]
        if len(adresses) &gt; 0:
            if adresses[0].numero == 0:
                return adresses[0], 1.0
            else:
                return adresses[0], 0.9
        else:
            return None, 0.0
    else:
        founds = [e for e in adresses if e.nom_afnor == adresse and e.numero == num]
        if len(founds) &gt; 0:
            return founds[0], 1.0
        else:
            nums = [e.numero for e in adresses if e.nom_afnor == adresse]
            res = self.find_nearest_num(num, nums)
            founds = [e for e in adresses if e.nom_afnor == adresse and e.numero == res]
            if len(founds) &gt; 0:
                score = max(1 - abs(res - num) / 10, 0.5)
                return founds[0], score
            return None, 0.0  # Normalement impossible</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.match_street"><code class="name flex">
<span>def <span class="ident">match_street</span></span>(<span>self, commune: str, adresse2: str, adresse3: str, cp: int) ‑> Tuple[str, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Match l'adresse3
:param commune: la commune
:param adresse2: adresse2
:param adresse3: adresse3
:param cp: le code postal
:return: la rue de la commune matchée</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_street(self, commune: str, adresse2: str, adresse3: str, cp: int) -&gt; Tuple[str, float]:
    &#34;&#34;&#34;
    Match l&#39;adresse3
    :param commune: la commune
    :param adresse2: adresse2
    :param adresse3: adresse3
    :param cp: le code postal
    :return: la rue de la commune matchée
    &#34;&#34;&#34;
    # adresse3 = special.street(cp, adresse3)
    ids = self.communes_db[commune]
    entities = [self.db[id] for id in ids]
    adresses = [e.nom_afnor for e in entities if e.code_postal == cp]
    adresses_voie = [e.nom_voie for e in entities if e.code_postal == cp]
    if adresse3 == &#34;&#34;:
        self.nbnostreet += 1
        adresse3 = &#34;MAIRIE EGLISE&#34;
    if adresse3 in adresses:
        return adresse3, 1.0
    if adresse3 in adresses_voie:
        index = adresses_voie.index(adresse3)
        return adresses[index], 0.99
    res, score = self.gestalts(adresse3, adresses)
    if score &gt; 0.8:
        return res, score
    res2, score2 = self.gestalts(adresse2, adresses)
    if score2 &gt; 0.8:
        return res2, score2
    res3, score3 = self.gestalts(adresse3, adresses_voie)
    if score + 0.1 &gt; max(score2, score3):
        return res, score
    if score2 &gt; score3:
        return res2, score2 * 0.8
    index = adresses_voie.index(res3)
    return adresses[index], score3 * 0.9</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.normalize_commune"><code class="name flex">
<span>def <span class="ident">normalize_commune</span></span>(<span>self, commune: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Normalise la commune
:param commune: commune
:return: la commune normalisée</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_commune(self, commune: str) -&gt; str:
    &#34;&#34;&#34;
    Normalise la commune
    :param commune: commune
    :return: la commune normalisée
    &#34;&#34;&#34;
    if &#34;CEDEX&#34; in commune:
        self.nbcedexbp += 1
        index = commune.index(&#34;CEDEX&#34;)
        commune = commune[:index]
    commune = commune.upper().replace(&#34;&#39;&#34;, &#34; &#34;).replace(&#34;-&#34;, &#34; &#34;).replace(&#34;.&#34;, &#34;&#34;).replace(&#34;/&#34;, &#34; &#34;)
    commune = &#34; &#34; + commune
    commune = commune.replace(&#34; ST &#34;, &#34; SAINT &#34;).replace(&#34; STE &#34;, &#34; SAINTE &#34;)
    return commune.strip()</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.normalize_street"><code class="name flex">
<span>def <span class="ident">normalize_street</span></span>(<span>self, street: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Normalise la rue
:param street: rue
:return: rue normalisée</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_street(self, street: str) -&gt; str:
    &#34;&#34;&#34;
    Normalise la rue
    :param street: rue
    :return: rue normalisée
    &#34;&#34;&#34;
    street = street.upper().replace(&#34;&#39;&#34;, &#34; &#34;).replace(&#34;-&#34;, &#34; &#34;).replace(&#34;.&#34;, &#34;&#34;).replace(&#34;/&#34;, &#34; &#34;).replace(&#39;&#34;&#39;, &#34;&#34;)
    street = &#34; &#34; + street
    if &#34; BP&#34; in street:
        self.nbcedexbp += 1
        street.replace(&#34; BP&#34;, &#34;&#34;)
    street = street.replace(&#34; CH &#34;, &#34; CHEMIN &#34;).replace(&#34; AV &#34;, &#34; AVENUE &#34;).replace(&#34; PL &#34;, &#34; PLACE &#34;)
    street = street.replace(&#34; BD &#34;, &#34; BOULEVARD &#34;).replace(&#34; IMP &#34;, &#34; IMPASSE &#34;).replace(&#34; ST &#34;, &#34; SAINT &#34;)
    street = street.replace(&#34; RT &#34;, &#34; ROUTE &#34;).replace(&#34; GAL &#34;, &#34; GENERAL &#34;)
    return street.strip()</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.parse_ps"><code class="name flex">
<span>def <span class="ident">parse_ps</span></span>(<span>self, dept: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction principale, charge PS et match un département
:param dept: un département</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_ps(self, dept: int):
    &#34;&#34;&#34;
    Fonction principale, charge PS et match un département
    :param dept: un département
    &#34;&#34;&#34;
    self.rownum = 0
    for row in self.csv:
        self.i += 1
        self.rownum += 1
        cp = int(row[7])
        if ((dept * 1000) &lt;= cp &lt; (dept + 1) * 1000 and cp != 201 and cp != 202) or \
                (dept == 201 and 20000 &lt;= cp &lt; 20200) or \
                (dept == 202 and 20200 &lt;= cp &lt; 21000):
            self.nb += 1
            entity = entities.PSEntity()
            entity.rownum = self.rownum
            self.ps_repo.row2entity(entity, row)
            t = (entity.cp, entity.commune, entity.adresse3, entity.adresse2)
            if t in self.adresses_db:
                aentity = self.db[self.adresses_db[t][0]]
                self.update_entity(entity, aentity, self.adresses_db[t][1])
                self.keys_db[entity.id] = (entity.adresseid, entity.score)
                self.pss_db.append(entity)
                if entity.adressescore &lt; config.adresse_quality:
                    self.nbscorelow += 1
            else:
                cp, score = self.match_cp(cp)
                entity.scores.append(score)
                communes = self.cps_db[cp]
                commune = self.normalize_commune(entity.commune)
                commune, score = self.match_commune(commune, communes, cp)
                entity.scores.append(score)
                if score &lt; 0.8:
                    cp2, commune2, score2 = self.get_cp_by_commune(self.normalize_commune(entity.commune), cp)
                    if score2 &gt; score and cp2 != entity.cp:
                        self.log(f&#34;WARNING BAD CP {entity.cp} {entity.commune}=&gt;{cp2} {commune2}&#34;)
                        self.nbbadcp += 1
                        cp = cp2
                        commune = commune2
                        entity.scores[1] = score2
                        entity.scores[0] = 0.5
                adresse3 = self.normalize_street(entity.adresse3)
                adresse2 = self.normalize_street(entity.adresse2)
                num, adresse3 = self.split_num(adresse3)
                if num == 0 and adresse2 != &#34;&#34;:
                    num, adresse2 = self.split_num(adresse2)
                originalnum = num
                matchadresse, score = self.match_street(commune, adresse2, adresse3, cp)
                entity.scores.append(score)
                aentity, score = self.match_num(commune, matchadresse, num)
                entity.scores.append(score)
                aentity = self.check_low_score(entity, adresse3, originalnum, aentity)
                self.update_entity(entity, aentity, entity.score)
                self.pss_db.append(entity)
                self.keys_db[entity.id] = (entity.adresseid, entity.score)
                self.adresses_db[t] = (entity.adresseid, entity.score)
                self.new_adresse = True</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.split_num"><code class="name flex">
<span>def <span class="ident">split_num</span></span>(<span>self, s: str) ‑> Tuple[int, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Split s en fonction du numero
:param s: chaine
:return: tuple numéro, reste de la chaine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_num(self, s: str) -&gt; Tuple[int, str]:
    &#34;&#34;&#34;
    Split s en fonction du numero
    :param s: chaine
    :return: tuple numéro, reste de la chaine
    &#34;&#34;&#34;
    regex = r&#34;(\d+)&#34;
    match = re.match(regex, s)
    if match is None:
        self.nonum += 1
        return 0, s
    num = match[1]
    index = s.index(match[1])
    return int(num), s[index + len(num):].strip()</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.update_entity"><code class="name flex">
<span>def <span class="ident">update_entity</span></span>(<span>self, entity: entities.PSEntity, aentity: entities.AdresseEntity, score: float)</span>
</code></dt>
<dd>
<div class="desc"><p>MAJ PS par rapport à l'adresse
:param entity: PS
:param aentity: adresse entity
:param score: le score de matching</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_entity(self, entity: entities.PSEntity, aentity: entities.AdresseEntity, score: float):
    &#34;&#34;&#34;
    MAJ PS par rapport à l&#39;adresse
    :param entity: PS
    :param aentity: adresse entity
    :param score: le score de matching
    &#34;&#34;&#34;
    entity.adresseid = aentity.id
    entity.adressescore = score
    entity.lon = aentity.lon
    entity.lat = aentity.lat
    entity.x = aentity.x
    entity.y = aentity.y
    entity.codeinsee = aentity.code_insee
    entity.matchadresse = f&#34;{aentity.numero} {aentity.nom_afnor} {aentity.code_postal} {aentity.commune}&#34;
    entity.matchcp = aentity.code_postal</code></pre>
</details>
</dd>
<dt id="icip.adressesmatcher.AdresseMatcher.very_last_chance"><code class="name flex">
<span>def <span class="ident">very_last_chance</span></span>(<span>self, cp: int, adresse3: str, num: int) ‑> Union[entities.AdresseEntity, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrouve une commune par code postal, adresse3 et numéro
:param cp: Le code postal
:param adresse3: adresse3
:param num: le numéro
:return: l'entité Adresse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def very_last_chance(self, cp: int, adresse3: str, num: int) -&gt; Optional[entities.AdresseEntity]:
    &#34;&#34;&#34;
    Retrouve une commune par code postal, adresse3 et numéro
    :param cp: Le code postal
    :param adresse3: adresse3
    :param num: le numéro
    :return: l&#39;entité Adresse
    &#34;&#34;&#34;
    if cp in self.cps_db:
        communes = self.cps_db[cp]
        for commune in communes:
            ids = self.communes_db[commune]
            for id in ids:
                e = self.db[id]
                if e.code_postal == cp and (e.nom_afnor == adresse3 or e.nom_voie == adresse3) and e.numero == num:
                    return e
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="icip" href="index.html">icip</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="icip.adressesmatcher.AdresseMatcher" href="#icip.adressesmatcher.AdresseMatcher">AdresseMatcher</a></code></h4>
<ul class="">
<li><code><a title="icip.adressesmatcher.AdresseMatcher.check_low_score" href="#icip.adressesmatcher.AdresseMatcher.check_low_score">check_low_score</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.denormalize_street" href="#icip.adressesmatcher.AdresseMatcher.denormalize_street">denormalize_street</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.display" href="#icip.adressesmatcher.AdresseMatcher.display">display</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.find_nearest_less_cp" href="#icip.adressesmatcher.AdresseMatcher.find_nearest_less_cp">find_nearest_less_cp</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.find_nearest_num" href="#icip.adressesmatcher.AdresseMatcher.find_nearest_num">find_nearest_num</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.gestalt" href="#icip.adressesmatcher.AdresseMatcher.gestalt">gestalt</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.gestalts" href="#icip.adressesmatcher.AdresseMatcher.gestalts">gestalts</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.get_cp_by_commune" href="#icip.adressesmatcher.AdresseMatcher.get_cp_by_commune">get_cp_by_commune</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.last_chance" href="#icip.adressesmatcher.AdresseMatcher.last_chance">last_chance</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.load_by_depts" href="#icip.adressesmatcher.AdresseMatcher.load_by_depts">load_by_depts</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.log" href="#icip.adressesmatcher.AdresseMatcher.log">log</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.match_commune" href="#icip.adressesmatcher.AdresseMatcher.match_commune">match_commune</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.match_cp" href="#icip.adressesmatcher.AdresseMatcher.match_cp">match_cp</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.match_num" href="#icip.adressesmatcher.AdresseMatcher.match_num">match_num</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.match_street" href="#icip.adressesmatcher.AdresseMatcher.match_street">match_street</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.normalize_commune" href="#icip.adressesmatcher.AdresseMatcher.normalize_commune">normalize_commune</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.normalize_street" href="#icip.adressesmatcher.AdresseMatcher.normalize_street">normalize_street</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.parse_ps" href="#icip.adressesmatcher.AdresseMatcher.parse_ps">parse_ps</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.split_num" href="#icip.adressesmatcher.AdresseMatcher.split_num">split_num</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.update_entity" href="#icip.adressesmatcher.AdresseMatcher.update_entity">update_entity</a></code></li>
<li><code><a title="icip.adressesmatcher.AdresseMatcher.very_last_chance" href="#icip.adressesmatcher.AdresseMatcher.very_last_chance">very_last_chance</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>